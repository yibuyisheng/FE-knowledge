* display: flex | inline-flex

	- flex ： 使元素生成一个块级伸缩容器框
	- inline-flex ： 使元素生成一个行内伸缩容器框
	
浮动不会影响伸缩容器的布局，伸缩容器的外边距不会和内容的外边距重叠。

所有的多列布局属性 `column-*` 都对伸缩容器不起作用。

`float` 和 `clear` 对伸缩条目不起作用，并且不会使其溢出伸缩容器之外。但是， `flex` 还是可以通过影响 `display` 属性来影响盒子的生成（浮动的元素会生成块级框）。

`vertical-align` 对伸缩条目不起作用。

伸缩容器上没有 `::first-line` 和 `::first-letter` 伪元素，并且也不会给祖先元素提供这种伪元素。

* 伸缩容器中直接包含的文本会形成匿名伸缩条目。但是，一个只包含空白字符的匿名伸缩条目不会被渲染，就像设置了 `display:none` 一样。

* 伸缩条目为自己的内容建立了一个新的格式化上下文，通常这个格式化上下文的类型由该伸缩条目的 `display` 值决定。伸缩条目自身是伸缩框，而不是块级框，它们参与父容器的伸缩格式化上下文，而不是一个块级格式化上下文。

* 伸缩容器中的绝对定位子元素不会参与伸缩布局，但是，会参与再排序步骤，这将会影响它们的绘制顺序。

* 伸缩容器绝对定位子元素的静态位置在伸缩伸缩布局之后通过设置子元素相对于伸缩容器内容区的静态位置矩形框来计算，然后绝对定位子元素在矩形框中根据伸缩父容器的 `justify-content` 值和子元素自身的 `align-self` 值来对齐。

* 伸缩项目之间的外边距不会重叠。自动外边距在相应的盒子中占据额外的空间，可用于对齐，以及分隔开伸缩子项目。

* 伸缩子项目的百分数外边距和内边距总是根据它们各自的盒子来计算。

 