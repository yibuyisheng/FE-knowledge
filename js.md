* JavaScript 并不是在所有换行处都填补分号，只是在缺少了分号就无法正确解析的时候才会填补。换句话讲，如果当前语句和随后的非空格字符不能当成一个整体来解析的话，JavaScript 就在当前语句行结束处填补分号。
* 通常来讲，如果一条语句以 “(”、“[”、“/”、“+”或“-”开始，那么它极有可能和前一条语句合在一起解析。但是此处有两个例外：
  
  - 第一个是在涉及 return 、 continue 和 break 的时候，如果这三个关键字后紧跟着换行， JavaScript 则会在换行处填补分号；
  - 第二个是在涉及“++”和“--”的时候，如果将其作为后缀表达式，它和表达式应当在同一行，否则，行尾将填补分号，同时“++”和“--”将会作为下一行代码的前缀操作符并与之一起解析。

* NaN 和任何值都不相等，包括自身。对于 x!=x ，当且仅当 x 为 NaN 的时候才为 true 。
* isNaN ，如果参数是 NaN 或者非数字值，则返回 true 。
* isFinite ，在参数不是 NaN 、 Infinity 或 -Infinity 的时候返回 true 。
* 0 === -1;
* 1/0 !== 1/-0;
* JavaScript 采用 UTF-16 编码的 Unicode 字符集， JavaScript 字符串是由一组无符号的16位值组成的序列。最常用的 Unicode 字符（这些字符属于“基本多语种平面（ Basic Multilingual Plane, BMP ）”）都是通过16位的内码表示，并代表字符串中的单个字符，那些不能表示为16位的 Unicode 字符则遵循 UTF-16 编码规则，用两个16位值组成的一个序列（亦称作“代理项对”）表示。这意味着一个长度为2的 JavaScript  字符串（两个16位值）有可能表示一个 Unicode 字符：
  
  ```js
  var p = "π";                   // π由16位内码表示0x03c0
  var e = "e";                   // e由17位内码表示0x1d452
  p.length                       // => 1：p包含一个16位值
  e.length                       // => 2：e通过 UTF-16 编码后包含两个16位值：“\ud835\udc52”
  ```
  
  JavaScript 定义的各式字符串操作方法均作用于16位值，而非字符，且不会对代理项作单独处理，同样 JavaScript 不会对字符串做标准化的加工，甚至不能保证字符串是否是合法的 UTF-16 格式。
  
* null == undefined
* null !== undefined
* 只要引用了字符串属性， JavaScript 就会将字符串通过调用 new String() 的方式转换成对象。一旦属性引用结束，这个新创建的对象就会被销毁（在实现上并不一定创建和销毁这个临时对象，但是整个过程看起来就是这样）。如下代码很好地说明了这个问题：

  ```js
  var s = '123';
  s.len = 4;
  var t = s.len;
  ```
  
  最后得到的 t 将会是 undefined。

* `==` 将原始值和其包装对象视为相等，而 `===` 则认为不等。
* 如果“+”运算符的一个操作数是字符串，则另外一个操作数将会转换成字符串。一元“+”运算符将其操作数转换为数字。一元“!”运算符将其操作数转换为布尔值并取反。
* JavaScript 中对象到字符串的转换经过了如下这些步骤：

  - 1、如果对象具有 toString() 方法，则调用这个方法。如果返回一个原始值，JavaScript 将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果；
  - 2、如果对象没有 toString() 方法，或者这个方法并不返回一个原始值，那么 JavaScript 会调用 valueOf() 方法。如果存在这个方法，则 JavaScript 调用它。如果返回是原始值， JavaScript 将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串的结果。
  - 3、否则， JavaScript 无法从 toString() 或 valueOf() 获得一个原始值，抛出类型错误异常。
  
  在对象到数字的转换过程中，会做同样的事情，只不过会首先尝试 valueOf() 方法。

* IE8 中的跨域方案： [XDomainRequest](https://msdn.microsoft.com/en-us/library/ie/cc288060(v=vs.85).aspx)

* 加号的转换规则优先考虑字符串连接，如果其中一个操作数是字符串或者转换为字符串的对象，另外一个操作数将会转换为字符串，加法将进行字符串的连接操作。如果两个操作数都不是字符串的，那么将进行算术加法运算。

  从技术上讲，加法操作符的行为表现为：
  
  - 如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始类值：日期对象通过 toString() 方法执行转换，其他对象则通过 valueOf() 方法执行转换（如果 valueOf() 方法返回一个原始值的话）。由于多数对象不具备可用的 valueOf() 方法，因此它们会通过 toString() 方法来执行转换。
  - 在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另一个操作数也会转换为字符串，然后进行字符串连接。
  - 否则，两个操作数都将转换为数字（或者 NaN ），然后进行加法操作。
  
  示例：
  
  ```js
  1 + 2 + " blind mice";            // => "3 blind mice"
  1 + (2 + " blind mice");          // => "12 blind mice"
  ```

* 在 JavaScript 中，一元运算符具有很高的优先级，而且都是右结合。

* “==” 运算符在两个操作数类型不同的情况下的转换：

  - ```null == undefined // true```
  - 如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较。
  - 如果其中一个值是 true ，则将其转换为 1 再进行比较，如果其中一个值是 false ，则将其转换为 0 再进行比较。
  - 如果一个值是对象，另一个值是数字或字符串，则将对象转换为原始值再进行比较。JavaScript 语言核心内置类首先尝试使用 valueOf() 转换为原始值，再用 toString() ，但是日期类只使用 toString() 转换。
  - 其他不同类型之间的比较均不相等。