* JavaScript 并不是在所有换行处都填补分号，只是在缺少了分号就无法正确解析的时候才会填补。换句话讲，如果当前语句和随后的非空格字符不能当成一个整体来解析的话，JavaScript 就在当前语句行结束处填补分号。
* 通常来讲，如果一条语句以 “(”、“[”、“/”、“+”或“-”开始，那么它极有可能和前一条语句合在一起解析。但是此处有两个例外：
  
  - 第一个是在涉及 return 、 continue 和 break 的时候，如果这三个关键字后紧跟着换行， JavaScript 则会在换行处填补分号；
  - 第二个是在涉及“++”和“--”的时候，如果将其作为后缀表达式，它和表达式应当在同一行，否则，行尾将填补分号，同时“++”和“--”将会作为下一行代码的前缀操作符并与之一起解析。

* NaN 和任何值都不相等，包括自身。对于 x!=x ，当且仅当 x 为 NaN 的时候才为 true 。
* isNaN ，如果参数是 NaN 或者非数字值，则返回 true 。
* isFinite ，在参数不是 NaN 、 Infinity 或 -Infinity 的时候返回 true 。
* 0 === -1;
* 1/0 !== 1/-0;
* JavaScript 采用 UTF-16 编码的 Unicode 字符集， JavaScript 字符串是由一组无符号的16位值组成的序列。最常用的 Unicode 字符（这些字符属于“基本多语种平面（ Basic Multilingual Plane, BMP ）”）都是通过16位的内码表示，并代表字符串中的单个字符，那些不能表示为16位的 Unicode 字符则遵循 UTF-16 编码规则，用两个16位值组成的一个序列（亦称作“代理项对”）表示。这意味着一个长度为2的 JavaScript  字符串（两个16位值）有可能表示一个 Unicode 字符：
  
  ```js
  var p = "π";                   // π由16位内码表示0x03c0
  var e = "e";                   // e由17位内码表示0x1d452
  p.length                       // => 1：p包含一个16位值
  e.length                       // => 2：e通过 UTF-16 编码后包含两个16位值：“\ud835\udc52”
  ```
  
  JavaScript 定义的各式字符串操作方法均作用于16位值，而非字符，且不会对代理项作单独处理，同样 JavaScript 不会对字符串做标准化的加工，甚至不能保证字符串是否是合法的 UTF-16 格式。
  
* null == undefined
* null !== undefined
* 只要引用了字符串属性， JavaScript 就会将字符串通过调用 new String() 的方式转换成对象。一旦属性引用结束，这个新创建的对象就会被销毁（在实现上并不一定创建和销毁这个临时对象，但是整个过程看起来就是这样）。如下代码很好地说明了这个问题：

  ```js
  var s = '123';
  s.len = 4;
  var t = s.len;
  ```
  
  最后得到的 t 将会是 undefined。

* `==` 将原始值和其包装对象视为相等，而 `===` 则认为不等。
* 如果“+”运算符的一个操作数是字符串，则另外一个操作数将会转换成字符串。一元“+”运算符将其操作数转换为数字。一元“!”运算符将其操作数转换为布尔值并取反。
* JavaScript 中对象到字符串的转换经过了如下这些步骤：

  - 1、如果对象具有 toString() 方法，则调用这个方法。如果返回一个原始值，JavaScript 将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果；
  - 2、如果对象没有 toString() 方法，或者这个方法并不返回一个原始值，那么 JavaScript 会调用 valueOf() 方法。如果存在这个方法，则 JavaScript 调用它。如果返回是原始值， JavaScript 将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串的结果。
  - 3、否则， JavaScript 无法从 toString() 或 valueOf() 获得一个原始值，抛出类型错误异常。
  
  在对象到数字的转换过程中，会做同样的事情，只不过会首先尝试 valueOf() 方法。

* IE8 中的跨域方案： [XDomainRequest](https://msdn.microsoft.com/en-us/library/ie/cc288060(v=vs.85).aspx)

* 加号的转换规则优先考虑字符串连接，如果其中一个操作数是字符串或者转换为字符串的对象，另外一个操作数将会转换为字符串，加法将进行字符串的连接操作。如果两个操作数都不是字符串的，那么将进行算术加法运算。

  从技术上讲，加法操作符的行为表现为：
  
  - 如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始类值：日期对象通过 toString() 方法执行转换，其他对象则通过 valueOf() 方法执行转换（如果 valueOf() 方法返回一个原始值的话）。由于多数对象不具备可用的 valueOf() 方法，因此它们会通过 toString() 方法来执行转换。
  - 在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另一个操作数也会转换为字符串，然后进行字符串连接。
  - 否则，两个操作数都将转换为数字（或者 NaN ），然后进行加法操作。
  
  示例：
  
  ```js
  1 + 2 + " blind mice";            // => "3 blind mice"
  1 + (2 + " blind mice");          // => "12 blind mice"
  ```

* 在 JavaScript 中，一元运算符具有很高的优先级，而且都是右结合。

* “==” 运算符在两个操作数类型不同的情况下的转换：

  - ```null == undefined // true```
  - 如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较。
  - 如果其中一个值是 true ，则将其转换为 1 再进行比较，如果其中一个值是 false ，则将其转换为 0 再进行比较。
  - 如果一个值是对象，另一个值是数字或字符串，则将对象转换为原始值再进行比较。JavaScript 语言核心内置类首先尝试使用 valueOf() 转换为原始值，再用 toString() ，但是日期类只使用 toString() 转换。
  - 其他不同类型之间的比较均不相等。
  
* 比较操作符

  只有数字和字符串才能真正执行比较操作，那些不是数字和字符串的操作数都将进行类型转换，规则如下：
  
  - 如果操作数为对象，则：valueOf() => toString()。
  - 在对象转换为原始值之后，如果两个操作数都是字符串，那么将按照字母表的顺序对两个字符串进行比较，此处“字母表顺序”是指组成这个字符串的16位 Unicode 字符的索引顺序。
  - 在对象转换为原始值之后，如果至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行数值比较。如果其中一个操作数是（或转换后是） NaN ，那么比较操作符总是返回 false 。

* eval() 使用了调用它的变量作用域环境。也就是说，它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样。

* 如果字符串作为一个单独的脚本是有语义的（就像 `x=0` 这种短代码），那么将其传递给 eval() 作参数是完全没有问题的，否则 eval() 将抛出语法错误异常。考虑如下抛出语法错误的例子：

  ```js
  // 示例1
  eval('return;');
  
  // 示例2
  var foo = function (a) {
    eval(a);
  };
  foo('return;');
  ```

* eval() 具有更改局部变量的能力，这对于 JavaScript 优化器来说是一个很大的问题。然而作为一种权宜之计， JavaScript 解析器针对那些调用了 eval() 的函数所做的优化并不多。但当脚本定义了 eval() 的一个别名，且用另一个名称调用它，此时 ECMAScript 3 规定应该抛出一个 EvalError 异常。

  实际上，大多数实现并不是这么做的。当通过别名调用时， eval() 会将其字符串当成顶层的全局代码来执行。执行的代码可能会定义新的全局变量和全局函数，或者给全局变量赋值，但却不能使用或修改主调函数中的局部变量，因此，这不会影响到函数内的代码优化。
  
  ECMAScript 5 是反对使用 EvalError 的，并且规范了 eval() 的行为。“直接的 eval”，当直接使用非限定的“ eval ”名称（ eval 看起来像是一个保留字）来调用 eval() 函数时，通常称为“直接 eval ”（ direct eval ）。直接调用 eval() 时，它总是在调用它的上下文作用域内执行。其他间接调用则会使全局对象作为其上下文作用域，并且无法读、写、定义局部变量和函数。
  
  IE9 之前的早期版本 IE 和其他浏览器有所不同，当通过别名调用 eval() 时并不是全局 eval() （它也不会抛出一个 EvalError 异常，仅仅将其当做局部 eval 来调用）。但 IE 的确定义了一个名叫 execScript() 的全局函数来完成全局 eval 的功能（但和 eval() 稍有不同， execScript() 总是会返回 null ）。
  
* 当在严格模式下调用 eval() 时，或者 eval() 执行的代码段以 “use strict” 指令开始，这里的 eval() 是私有上下文环境中的局部 eval 。也就是说，在严格模式下， eval 执行的代码段可以查询或更改局部变量，但不能在局部作用域中定义新的变量或函数。

  此外，严格模式将“ eval ”列为保留字，这让 eval() 更像一个运算符。不能用一个别名覆盖 eval() 函数。并且变量名、函数名、函数参数或者异常捕获的参数都不能取名为 “eval” 。
  
* delete 希望它的操作数是一个左值，如果不是，那么 delete 将不进行任何操作同时返回 true 。否则， delete 将试图删除这个指定的左值。如果删除成功， delete 将返回 true 。

  并不是所有属性都可以删除，一些内置核心和客户端属性是不能删除的，用户通过 var 语句声明的变量不能删除。通过 function 语句定义的函数和函数参数也不能删除。
  
  在 ECMAScript 5严格模式中，如果 delete 的操作数是非法的，比如变量、函数或函数参数， delete 操作将抛出一个语法错误（ SyntaxError ）异常，只有操作数是一个属性访问表达式的时候它才会正常工作。在严格模式下， delete 删除不可配置的属性时会抛出一个类型错误异常。在非严格模式下，这些 delete 操作都不会报错，只是简单地返回 false ，以表明操作数不能执行删除操作。
  
  ```js
  var a = {t: 1};
  console.log('t' in a); // true
  delete a.t;
  console.log('t' in a); // false
  ```
  
* void 是一元运算符，它出现在操作数之前，操作数可以是任意类型。操作数会照常计算，但忽略计算结果并返回 undefined 。由于 void 会忽略操作数的值，因此在操作数具有副作用的时候使用 void 来让程序更语义。

* 思考如下代码：
  ```js
  fun1(); // throw ReferenceError: fun1 is not defined
  fun2(); // throw TypeError: undefined is not a function
  var fun2 = function fun1() {
      console.log('function');
  }
  ```
  
* for/in 循环只能遍历 “可枚举” 的属性。由 JavaScript 语言核心所定义的内置方法就不是“可枚举的”。

  除了内置方法之外，还有很多内置对象的属性也是“不可枚举的”。
  
  代码中定义的所有属性和方法都是可枚举的，但在 ECMAScript 5中可以通过特殊手段让可枚举属性变为不可枚举。
  
  那些继承的自定义属性也可以使用 for/in 枚举出来。
  
  如果 for/in 删除了还未枚举的属性，那么这个属性将不会再枚举到。
  
  如果循环体定义了对象的新属性，这些属性通常也不会枚举到（ JavaScript 有些实现是可以枚举到那些在循环体中增加的继承属性的）。
  
* 思考如下代码：
  ```js
  function fun1() {
      try {
          return 1;
      } catch(e) {
          return 2;
      } finally {
          return 3;
      }
  }
  
  console.log(fun1()); // 3
  
  function fun2() {
      try {
          throw new Error('');
          return 1;
      } catch(e) {
          return 2;
      } finally {
          return 3;
      }
  }
  
  console.log(fun2()); // 3
  ```